#!/usr/bin/env zep-2.0

plugin zep_display;
plugin zep_sound;
plugin zep_ioteensy;

import stats;

dur g_isi       = dur(16.0 + 2.0/3.0);  // default (inter-) stimulus dur
dur g_test_dur  = 60s;                  // default test dur.
//dur g_test_dur  = 6s;                  // short dur.
bool g_verbose  = false;                // whether verbose printing is on
bool g_easter   = false;                // enables Easter eggs.

const int SOUND_PIN = 9;                // Audio connection pin
const int CONTINUE = 0;                 // normally defined by default modules.

// output values
record Output
{
    int first_time;
    int last_time;
}

Output[..] output;

Teensy teensy
{
    int tstart;
    int tend;

    void reset()
    {
        tstart  = 0;
        tend    = 0;
    }

    on_event:triggered()
    {
        if (!tstart)
            tstart = timestamp;
        tend = timestamp;
    }
}

Timer capture_timings
{
    on_event:expire()
    {
        Output out;
        out.first_time = teensy.tstart;
        out.last_time  = teensy.tend;
        output_append(out);
        teensy.reset();
    }

    void output_append(Output out)
    {
        output.size = output.size + 1;
        output[output.size - 1] = out;
    }
}

NormalWindow test_window
{
    on_event:init()
    {
        position_and_size = 0,0,500,500;
        alignment = ALIGN_CENTER, ALIGN_CENTER;
        show();
    }

    on_event:show()
    {
        // Get keyboard focus when shown.
        activate();
    }
}

/**
 * We only use a test page to get keyboard input.
 */
Page test_page
{
    on_event:init()
    {
        println("The next keys can be pressed for the following functions:\n\n");
        println("Esc\tstop the experiment\n");
    }

    on_event:key_press()
    {
        if (input_key == KEY_Escape)
        {
            terminate;
        }
    }
}


SoundPlaybackDevice output_device
{
    init()
    {
        int nch = 2;
        int device_id = -1;
//        int sr = RATE_48000;
        int sr = RATE_192000;
        if (have_option("nch"))
        {
            nch = int(option_value("nch"));
            if (nch < 2 || nch > 8)
                terminate "nch must be: 2 <= nch <=8\n";
        }
        if (have_option("sr"))
        {
            sr = int(option_value("sr"));
            if (sr < RATE_8000 || sr > RATE_192000)
                terminate "sr must be: 8000 <= sr <=192000\n";
        }
        if (have_option("sounddevice")) {
            device_id = int(option_value("sounddevice"));
        }
        println("Opening sounddevice" );
        println("\tid = \t\t" + device_id);
        println("\tnum chan =\t" + nch);
        println("\tsample rate =\t" + sr);

        open(nch, sr, device_id);
        if (error()) terminate "Unable to open sound device.\n";

        //hardware_latency = 3.3ms;
    }
}


SoundPlayback stimulus
{
    init()
    {
        device = output_device;

        // Must be done after opening the device and after connecting to
        // the device (in order to assume correct sample rate).
        clip.duration = 1ms;
    }

    on_event:finish()
    {
        done(CONTINUE);
        capture_timings.start(event_time + 5ms);
    }

    void done(int val)
    {
        abort();
        signal_target(CONTINUE);
    }

    void set_target(Object obj)
    {
        target = obj;
    }

    BeepGenerator clip
    {
        init()
        {
            //frequency[0] = 880;
            //frequency[0] = 1000;
            //frequency[0] = 5000;
            frequency[0] = output_device.samplerate/4;

            scaling  [0] = 0.99;
        }
    }
}

/**
 * The trials block presents as the name suggests, the trials. It calculates
 * how many are needed given the length of the sound stimuli and the total
 * duration of the test.
 */
Block trials
{
    on_event:entry()
    {
        num_cycles = int(g_test_dur / (real(g_isi) * 2));
        stimulus.clip.duration = g_isi;
    }

    on_event:exit()
    {
    }

    /**
     * Presents first g_isi of inter stimulus interval and then with the same
     * duration a stimulus will be played.
     */
    Trial trial {

        on_event:entry()
        {
            stimulus.set_target(this);
            stimulus.start(reference_time + g_isi);
        }
    }
}

Timer terminator
{
    real [..] diff_starts;
    real [..] diff_ends;
    real [..] diff_durs;

    on_event:expire()
    {
        print_ouput();
        if (g_easter)
            println("Hasta la vista, baby.");
        terminate;
    }

    void append(real[] array, real value)
    {
        array.size = array.size + 1;
        array[array.size-1] = value;
    }

    void print_ouput()
    {
        int i = 1;
        while (i < output.size)
        {
            append(diff_starts, output[i].first_time - output[i-1].first_time);
            append(diff_ends  , output[i].last_time  - output[i-1].last_time);
            append(diff_durs  , output[i].last_time  - output[i].first_time);
            i++;
        }

        if (g_verbose) {

            println("start\tend\tdur");

            i = 0;
            while (i < diff_starts.size) {
                println("" + diff_starts[i] + "\t" +
                             diff_ends[i]   + "\t" +
                             diff_durs[i]
                        );
                i++;
            }
        }

        println();
        println("\tmean\tstd");
        println("on-off\t" + mean(diff_durs)/1000 + "\t" + std(diff_durs)/1000);
        println("onsets\t" + mean(diff_starts)/1000 + "\t" + std(diff_starts)/1000);
        println("offsets\t" + mean(diff_ends)/1000 + "\t" + std(diff_ends)/1000);
    }
}

start()
{
    test_window.show_page(test_page);
    string teensy_dev = "/dev/ttyACM0";

    if (have_option("hwlatency"))
        output_device.hardware_latency = dur(option_value("hwlatency"));

    if (have_option("isi"))
        g_isi = dur(option_value("isi"));

    if (have_option("freq"))
        stimulus.clip.frequency[0] = int(option_value("freq"));

    if (have_option("dev"))
        teensy_dev = option_value("dev");

    if (have_flag("egg"))
        g_easter = true;

    if (have_option("verbose") || have_option("v"))
        g_verbose = true;
    

    // Set up teensy and abort on error.
    teensy.open(teensy_dev);
    if (error())
        terminate;

    teensy.register_input_trigger(SOUND_PIN);
    if (error())
        terminate;

    terminator.start(event_time + g_test_dur + 2500ms);

    trials.enter();
}

