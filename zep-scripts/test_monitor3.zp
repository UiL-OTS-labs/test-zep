#!/usr/bin/env zep-2.0

/*************** importing plugins *********/
plugin zep_display;
plugin zep_string;
plugin zep_struct;
plugin zep_ioteensy;

/*************** Zep specific **************/
// Continue is normally defined in defs.zm or since Zep-2.0 in std_control.zm
const int CONTINUE          = 0;

/*************** global variables **********/
int g_width                 = 500;
int g_height                = 500;
int g_fps                   = 60;
int g_nframes               = 1;        // Number of frames between stimulus
                                        // color.
int g_tot_frames            = 60 * 60;  // One minute.
//int g_tot_frames            = 6 * 60;  // One tenth of a minute.

bool g_terminate_on_finish  = true;

const int PHOTO_DIODE_PIN   = 10;

/*************** utilities ********/

record Output
{
    int timestamp;
    int logic_level;
}

/*************** objects *********/
Teensy teensy {

    Output[..]  output;
    real[..]    diffs; // differential vector (shows interval between two 
                       // successive frames).
    real        edur;  // expected stimulus duration.
    real        fdur;  // theoretical frame duration.

    on_event:init()
    {
        // reallocating memory might prove expensive.
        output.capacity = 60 * 60 + 10;
        diffs.capacity = output.capacity;
    }

    on_event:triggered()
    {
        Output out;
        out.timestamp   = timestamp;
        out.logic_level = line_value;
        append(out);
    }

    void append(Output out)
    {
        output.size = output.size + 1;
        output[output.size - 1] = out;
    }

    void set_expected_durations(real fdur_us, real sdur_us)
    {
        fdur = fdur_us;
        edur = sdur_us;
        println();
        println( "frame dur             = " + fdur + " µs");
        println( "expected stimulus dur = " + edur + " µs");
        println( "valid stim interval   = " + (edur - .75 * fdur) +
                                          " µs < dur < "
                                            + (edur + .25 * fdur) + " µs"
                                            );
    }

    on_event:cleanup()
    {
        int i;
        int mframe;
        int sframe;
        while (i < output.size)
        {
            if (i == 0)
                println("" + output[i].logic_level + "\t" + output[i].timestamp);
            else
            {
                println("" + output[i].logic_level + "\t"
                           + output[i].timestamp   + "\t" 
                           + (output[i].timestamp - output[i-1].timestamp)
                        );
                diffs.size = diffs.size + 1;
                diffs[diffs.size-1] =
                        output[i].timestamp - output[i-1].timestamp;
            }
            i++;
        }

        i = 0;
        while(i < diffs.size)
        { 
            if (diffs[i] > edur + .25 * fdur)
                mframe++;
            else if (diffs[i] < edur - .75 * fdur)
                sframe++;
            i++;
        }
        println();
        println("missed frames  = " + mframe);
        println("to short stims = " + sframe);
        println("total frames   = " + output.size);
    }
}

RawWindow test_window
{
    on_event:init()
    {
        position_and_size = 0, 0, 500, 500;
        // disable for testing with zep-1.4
        //alignment = ALIGN_CENTER, ALIGN_CENTER;

        if (os_name() == "Windows")
        {
            blit_full_window = true;
//            flush_after_blit = true;  // don't use
        }
        else
        {
            flush_after_blit = true;
        }
 
        show();
    }

    on_event:show()
    {
        // Get keyboard focus when shown.
        activate();
    }
}

/**
 * The test_page presents one big grayish screens with 3 black/white rectangles.
 *
 * The rectangles overlap each other in space but are presented interleaved
 * in time. The black rectangles are presented first and then the white's.
 */
Page test_page
{

    on_event:init()
    {
        println("The next keys can be pressed for the following functions:\n\n");
        println("s\tStart the task.\n");
        println("Esc\tstop the experiment\n");

        println("F1\tput the window on the first head.");
        println("F2\tput the window on the second head.");
        println("F3\tput the window on the third head.");
        println("F4\tput the window on the fourth head.");
        println("F5\tswitch window width.");
        println("F6\tswitch window height.");
        println("F7\ttoggle blit full window (true for windows by default).");
        println("F8\ttoggle flush window after blit.");
        println("F10\t(un)maximize window.");
        println("F11\ttoggle full screen window.");
    }

    on_event:key_press()
    {
        if (input_key == KEY_Escape)
        {
            terminate;
        }
        else if (input_key == KEY_F1)
        {
            test_window.target_head = 0;
        }
        else if (input_key == KEY_F2)
        {
            if (display_device.num_heads >= 2)
                test_window.target_head = 1;
        }
        else if (input_key == KEY_F3)
        {
            if (display_device.num_heads >= 3)
                test_window.target_head = 2;
        }
        else if (input_key == KEY_F4)
        {
            if (display_device.num_heads >= 4)
                test_window.target_head = 3;
        }
        else if (input_key == KEY_F5)
        {
            if (test_window.width >= display_device.width / 2)
                test_window.size = 200, test_window.height;
            else
                test_window.size = display_device.width, test_window.height;
        }
        else if (input_key == KEY_F6)
        {
            if (test_window.height >= display_device.height / 2)
                test_window.size = test_window.width, 100;
            else
                test_window.size = test_window.width, display_device.height;
        }
        else if (input_key == KEY_F7)
        {
            if (input_modifiers & INPUT_MOD_CONTROL)
                test_window.blit_full_window = true;
            else
                test_window.blit_full_window = false;
        }
        else if (input_key == KEY_F8)
        {
            if (input_modifiers & INPUT_MOD_CONTROL)
                test_window.flush_after_blit = true;
            else
                test_window.flush_after_blit = false;
        }
        else if (input_key == KEY_F10)
        {
            test_window.is_maximized = !test_window.is_maximized;
        }
        else if (input_key == KEY_F11)
        {
            test_window.is_fullscreen = !test_window.is_fullscreen;
        }
        else if (input_key == 's' || input_key == 'S')
        {
            start_experiment();
        }
    }

    CanvasGadget canvas
    {
        on_event:init()
        {
            fill_pattern_color  = color:white;
        }

        RectangleShape rect // upper left corner
        {
            on_event:init()
            {
                width               = g_width;
                height              = g_height;
                fill_pattern_color  = rgbi:0/0/0;
            }

            on_event:pre_update()
            {
                if ((relative_frame / g_nframes) % 2 == 0)
                    is_visible = true;
                else
                    is_visible = false;
            }

            on_event:finish()
            {
                if (g_terminate_on_finish)
                    terminate;
            }
        }
    }

    void start_experiment ()
    {
        real expected_framedur = 
                real(display_device.refresh_interval[test_window.target_head]);
        expected_framedur = expected_framedur * 1000; // convert ms to µs
        real expected_stimdur  = g_nframes * expected_framedur;

        teensy.set_expected_durations(expected_framedur, expected_stimdur);
        int start_frame = display_device.current_frame_counter[
                test_window.target_head
                ];

        canvas.rect.start_fr(start_frame + g_fps/2 , g_tot_frames);
        teensy.register_input_trigger(PHOTO_DIODE_PIN);
    }
}

start()
{
    test_window.show_page(test_page);
    test_page.hide_cursor();
    string device = "/dev/ttyACM0";

    display_device.open();
    if (error())
        terminate "Unable to open display device\n";
    
    if (have_option("dev"))
        device = option_value("dev");
    
    if (have_option("nframes")) {
        g_nframes = int(option_value("nframes"));
        if (g_nframes <= 0)
            terminate "option nframes has invalid value, nframes must be > 0\n";
    }

    if (have_option("fps")) {
       g_fps = int(option_value("fps"));
       if (g_fps <= 0)
           terminate "option fps has invalid value, fps must be > 0\n";
    }

    teensy.connect(device);
    if(error()) {
        terminate "Unable to open teensy.";
    }
}

